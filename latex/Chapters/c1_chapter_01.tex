%!TEX root = ../thesis.tex

\chapter{LOCKER}
\label{chap:loker}  %% відмічайте кожен розділ певною міткою -- на неї наприкінці необхідно посилатись

\section{Базові означення}

\begin{definition}
    Показник рангу над $F_{q^m}^n$ $x = (x_1, ..., x_n)$ - вектор в  $F_{q^m}^n$ і $(\beta_1, ..., \beta_n)$ - базис в $F_{q^m}^m$.
    
    Кожна координата $x_j$ є вектором в $F_{q}^m$ $x_j = \sum_{i=1}^m m_{ij}\beta_i$, де $m_{ij}$ - елемент матриці $M(x)$

    Тоді:
    \begin{equation}
        ||x|| = Rank M(x)
    \end{equation}

    відстань між $x$ та $y$ $d(x, y) = ||x-y||$
\end{definition}

\begin{definition}
    $F_{q^m}$ Лінійний код $C$ розмірності $k$ і довжини $n$ це підпростір розмірності $k$ простору $F_{q^m}^n$ вбудований з метрикою рангу. 

    Позначається $[n, k]_{q^m}$

    $C$ можна виразити двома способами

    \begin{enumerate}
        \item Через породжуючу матрицю $H \in F_{q^m}^{kn}$, кожен рядок матриці $G$ елемент базису $C$: 
        \begin{equation}
            C = \{xG, x \in F_{q^m}^k\}
        \end{equation}
        \item Через матриця перевірки парності $H \in F_{q^m}^{(n-k)n}$ кожен рядок $H$ визначає перевірку парності
        рівняння, перевірене елементами $C$:
        \begin{equation}
            C = \{x \in F_{q^m}^k, Hx^T = 0\}
        \end{equation}
    \end{enumerate}

    Ми говоримо, що $G$ (відповідно $H$) має систематичний вигляд, якщо він має форму $(I_k|A)$ (відповідно $(I_{n-k}|B)$).
\end{definition}

\begin{definition} (Підтримка слова)
    $x = (x_1, ..., x_n) \in F_{q^m}^n$. 

    Підтримка $E$ з $x$, позначається $Supp(x)$, є $F_q$-підпростором $F_{q^m}$, породженим координатами $x$:
    \begin{equation}
        E = <x_1,...,x_n>F_q
    \end{equation}

    $dimE = ||x||$.

    Кількість опор розмірності $w$ з $F_{q^m}$ позначається коефіцієнтом Гауса

    \begin{equation}
        [\dfrac{m}{w}] = \prod_{i=0}^{w-1} \dfrac{q^m - q^i}{q^w - q^i}
    \end{equation}
\end{definition}

\section{Подвійний циркулянт і ідеальні коди}

Щоб описати $[n,k]_{q^m}$ лінійний код, ми можемо дати його систематичну генераторну матрицю або його систематичну матрицю перевірки парності. 
В обох випадках кількість бітів, необхідних для представлення такої матриці, 
дорівнює $k(n-k)m \log_2 q$. Щоб зменшити розмір подання коду, ми вводимо подвійні циркулянтні коди.


Спочатку нам потрібно визначити циркулянтні матриці.

\begin{definition}
    (Циркулянтна матриця). Квадратна матриця $M$ розміром $n \times n$ називається циркулянтом,
    якщо вона має форму:
    \begin{equation}
        M = \begin{bmatrix}
            m_{0}       & m_{1} & m_{2} & \dots & m_{n-1} \\
            m_{n-1}     & m_{0} & m_{1} & \dots & m_{n-2} \\
            \hdotsfor{5} \\
            m_{1}       & m_{2} & m_{3} & \dots & m_{0}
        \end{bmatrix}
    \end{equation}
\end{definition}

Позначимо $M_n(F_{q^m})$ множину циркулянтних матриць розміру $n \times n$ над $F_{q^m}$.
Наступне твердження визначає важливу властивість циркулянтних матриць.

\begin{claim}
    $M_n(F_{q^m})$ є $F_{q^m}$ -алгеброю, ізоморфною $F_{q^m}[X]/(X^n - 1)$, 
    тобто набору поліномів із коефіцієнтами у $F_{q^m}$ за модулем $(X^n - 1)$. Канонічний ізоморфізм задано формулою

    \begin{gather} 
        \phi : F_{q^m}[X]/(X^n - 1) \rightarrow M_n(F_{q^m}) \\ 
        \sum_{i=0}^{n-1} m_i X^i \rightarrow\begin{bmatrix}
            m_{0}       & m_{1} & m_{2} & \dots & m_{n-1} \\
            m_{n-1}     & m_{0} & m_{1} & \dots & m_{n-2} \\
            \hdotsfor{5} \\
            m_{1}       & m_{2} & m_{3} & \dots & m_{0}
        \end{bmatrix}
    \end{gather} 
\end{claim}

Далі, щоб спростити позначення, ми будемо ідентифікувати поліном 
$G(X) = \sum_{i=0}^{n-1} g_i X^i \in F_{q^m}[X]$ 
з вектором $g = (g_0,...,g_{n-1}) \in F^n_{q^m}$. 

Позначимо $u g mod P$ вектор коефіцієнтів полінома $(\sum_{j=0}^{n-1} u_j X^j )(\sum_{i=0}^{n-1} g_i X^i ) mod P$
або просто $ug$, якщо немає неоднозначності у виборі полінома $P$.

\begin{definition} (Подвійні циркулянтні коди)
    Лінійний код $[2n, n]_{q^m} C$ називається подвійним циркулянтом, 
    якщо він має генеруючу матрицю $G$ у вигляді $G = (A|B)$, де $A$ і $B$ 
    є двома циркулянтними матрицями розміру $n$.
\end{definition}

З попередніми позначеннями маємо $C =\{(xa,xb), x \in F_{q^m}\}$. 
Якщо $a$ оборотне в $F_{q^m}[X]/(X^n - 1)$

тоді $C =\{(x,xg),x \in F_{q^m}\}$, де $g = a^{-1}b$. У цьому випадку $C$ породжується $g ( mod X^n - 1)$. 
Таким чином, нам потрібно лише $nm \log_2 q$ бітів для опису $[2n, n]_{q^m}$ подвійного циркулянтного коду.

Ми можемо узагальнити подвійні циркулянтні коди, вибравши інший поліном $P$ для визначення факторкільця  $F_{q^m}[X]/(P)$.
    

\begin{definition} (Ідеальні коди). Нехай $P(X) \in F_q[X]$ — поліном ступеня $n$ і $g_1$,$g_2 \in F_{q^m}$. 
    Нехай $G_1(X) = \sum_{i=0}^{n-1} g_{1i} X^{i}$,  
    $G_2(X) = \sum_{j=0}^{n-1}  g_{1j} X^{j}$ поліноми, асоційовані відповідно з $g_1$ і $g_2$.
\end{definition}

За визначенням, $[2n,n]_{q^m}$ ідеальний код $C$ генератора $(g_1,g_2)$ є кодом з генераторною матрицею

\begin{equation}
    G = \begin{bmatrix}
        G_{1}(X) mod P & G_{2}(X) mod P \\
        X G_{1}(X) mod P & X G_{2}(X) mod P \\
        \hdotsfor{2} \\
        X^{n-1} G_{1}(X) mod P & X^{n-1} G_{2}(X) mod P
    \end{bmatrix}
\end{equation}

\section{Складні задачі в ранговій метриці}

У цьому розділі представляємо складні проблеми, на яких базується криптосистема.

\begin{problem} (Розшифровка рангового синдрому) 
    Дано матрицю повного рангу $H \in F_{q^m}^{(n-k) \times n}$
    синдрому $\sigma$ і ваги $w$, важко взяти вектор $x \in F_{q^m}$ ваги меншої за $w$
    так, що $Hx^T =\sigma^T$.
\end{problem}

Проблема RSD нещодавно була доведена важкою для ймовірнісної редукції.

\begin{problem} (Розшифровка синдрому ідеального рангу)

    Заданий вектор $h \in F^n_{q^m}$ поліном $P$ ступеня $n$, синдром $\sigma$ і вага $w$, важко взяти вектор 
    $x = (x_1, x_2) F^{2n}_{q^m}$ ваги меншої за $w$, так що $x_1 + x_2 h = \sigma mod P$
\end{problem}

Оскільки $h$ і $P$ визначають систематичну матрицю перевірки парності ідеального коду $[2n,n]_{q^m}$,
I-RSD Проблема є окремим випадком задачі RSD.

\begin{problem} (Відновлення підтримки ідеального рангу)
    Дано вектор $h \in F_{q^m}$, поліном
    $P \in F_q[X]$ ступеня $n$, синдрому $\sigma$ і ваги $w$, важко відновити опору $E$ розмірності, нижчої за $w$, 
    так що $e_1 + e_2h = \sigma mod P$, де вектори $e_1$ і $e_2$ були відібрані з $E$.
\end{problem}

Проблема I-RSR тривіально зводиться до задачі I-RSD. 
Дійсно, щоб відновити опору $E$ екземпляра проблеми I-RSD із розв’язку x проблеми I-RSD, нам просто потрібно обчислити опору $x$.
Відповідно, проблему I-RSD також можна звести до задачі I-RSR. Припустимо, що нам відомий носій $E$ розв’язку задачі I-RSR для ваги $w$. Ми хочемо знайти $x=(x1,x2)$ ваги, меншої за $w$, щоб $x_1+x_2 h=\sigma modP$.

% \section{Коди перевірки парності низького рангу}
% TODO

\section{LOCKER IND-CPA PKE на основі метрики рангу}

\subsection{Визначення та модель безпеки}

Схема шифрування з відкритим ключем (PKE - Public Key Encryption) 
визначається трьома алгоритмами: алгоритмом генерації ключів KeyGen, 
який приймає на вході параметр безпеки $\lambda$ 
і виводить пару відкритих і закритих ключів $(pk,sk)$; 
алгоритм шифрування $Enc(pk,M)$, який виводить зашифрований текст $C$, 
що відповідає повідомленню $M$, і алгоритм дешифрування $Dec(sk,C)$, 
який виводить відкритий текст $M$.
Cхема PKE містить хеш-функцію $G$.

\begin{enumerate}
    \item $KeyGen(1^{\lambda})$:
    \begin{enumerate}
        \item виберемо незвідний поліном $P \in F_q[X]$ ступеня $n$.
        \item вибрати рівномірно навмання підпростір $F$ у $F_{q^m}$ розмірності $d$ і вибірку a 
        пара векторів $(x, y)$  $F^n \times F^n$ таких, що $x$ є оборотним за модулем $P$, 
        $Supp(x, y) = F$.
        \item обчислити $h = x^{-1}y mod P$.
        \item визначимо $pk = (h,P)$ і $sk = (x,y)$.
    \end{enumerate}
    \item $Enc(pk,M)$:
    \begin{enumerate}
        \item вибрати рівномірно навмання підпростір $E$ у $F_{q^m}$ розмірності $r$ і вибираємо пару векторів $(e_1, e_2)$ $E_n \times E_n$, $Supp(e_1, e_2) = E$.
        \item обчислити $c=e_1+e_2h mod P$ і $\tilde{C}=M \xor G(E)$.
        \item вивести зашифрований текст $C = (c, \tilde{C})$.
    \end{enumerate}
    \item $Dec(sk,C)$:
    \begin{enumerate}
        \item обчислити $xc = xe_1 + ye_2 mod P$ і відновити $E$ за допомогою алгоритму відновлення підтримки.
        \item результат $M = \tilde{C} \xor G(E)$.
    \end{enumerate}
\end{enumerate}

\textbf{Коректність:}
оскільки $P$ знаходиться у $F_q[X]$, $xc$ має підтримку в просторі продукту $<E.F>$, отже, знаючи $F$, 
можна застосувати алгоритм RS-Recover з попереднього розділу, який відновлює $E$.

\textbf{Обчислювальна вартість:}
Вартість $Encaps$ відповідає поліноміальній інверсії $mod P$ у $F_{q^m}$, для вартості множення елементів $F_{q^m}$ у $m \log(m) \log(\log(m))$,
 ми отримуємо складність шифрування в $O (n^2 \log(n)m \log (m) \log (\log (m)))$. 
 Вартість $Decaps$ — це матриця-вектор множення вартості $O(n^2 m \log(m) \log(\log(m)))$ 
 плюс вартість декодування алгоритму RS-Recover (перетинів підпросторів розмірності $rd$ у $F_{q^m}$) у $O((rd)^2 m)$.